#9
import threading
import queue
import time
import random

class VegetableMarket:
    def __init__(self, capacity):
        self.capacity = capacity
        self.vegetable_queue = queue.Queue(maxsize=capacity)
        self.farmers = []
        self.consumers = []
        self.lock = threading.Lock()

    def add_farmer(self, farmer):
        self.farmers.append(farmer)

    def add_consumer(self, consumer):
        self.consumers.append(consumer)

    def sell_vegetable(self, farmer, vegetable):
        with self.lock:
            if not self.vegetable_queue.full():
                self.vegetable_queue.put(vegetable)
                print(f"{farmer} added {vegetable} to the market.")
            else:
                print(f"{farmer} is waiting. Market is full.")

    def buy_vegetable(self, consumer, vegetable):
        with self.lock:
            try:
                bought_vegetable = self.vegetable_queue.get(timeout=5)
                print(f"{consumer} bought {bought_vegetable}.")
            except queue.Empty:
                print(f"{consumer} is waiting. Out of stock for {vegetable}.")

def farmer_function(farmer, market):
    vegetables = ['Tomato', 'Cucumber', 'Carrot', 'Spinach', 'Broccoli']
    while True:
        time.sleep(random.uniform(1, 3))
        vegetable = random.choice(vegetables)
        market.sell_vegetable(farmer, vegetable)

def consumer_function(consumer, market):
    vegetables_to_buy = ['Tomato', 'Cucumber', 'Carrot', 'Spinach', 'Broccoli']
    while True:
        time.sleep(random.uniform(2, 4))
        vegetable_to_buy = random.choice(vegetables_to_buy)
        market.buy_vegetable(consumer, vegetable_to_buy)

if __name__ == "__main__":
    market = VegetableMarket(capacity=5)

    for i in range(3):
        farmer = f"Farmer-{i + 1}"
        market.add_farmer(farmer)
        threading.Thread(target=farmer_function, args=(farmer, market)).start()

    for i in range(5):
        consumer = f"Consumer-{i + 1}"
        market.add_consumer(consumer)
        threading.Thread(target=consumer_function, args=(consumer, market)).start()
